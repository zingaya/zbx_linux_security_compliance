#!/usr/bin/env python3
import ansible_runner
import json
import os
import re
import time
import argparse
import shutil
from zabbix_utils import ItemValue, Sender

# Constants for file paths and Zabbix configuration
PLAYBOOK_PATH = "/path/linux_security_compliance.yaml"
INVENTORY_PATH = "/path/hosts"
ZABBIX_SERVER = "x.x.x.x"
ZABBIX_PORT = "10051"
ZABBIX_DEF_HOSTNAME = 'myhost' # Which Zabbix host have the item to drop logs from this script

def read_json_output(file_path):
    """Read and return JSON data from a file."""
    with open(file_path, 'r') as file:
        return json.load(file)

def remove_ansi_escape_codes(text):
    """Remove ANSI escape codes from a string."""
    ansi_escape = re.compile(r'\x1b\[([0-9;]*)m')
    return ansi_escape.sub('', text)

def generate_playbook(playbook_template, playbook_path, upgrade_param):
    """Generate a playbook file from a template with an upgrade parameter."""
    with open(playbook_template, 'r') as template_file:
        content = template_file.read()
    content = content.replace('{{ upgrade_param }}', upgrade_param)
    with open(playbook_path, 'w') as playbook_file:
        playbook_file.write(content)

def clean_temp_directory(directory):
    """Remove and recreate a temporary directory."""
    try:
        shutil.rmtree(directory)
    except FileNotFoundError:
        pass
    os.mkdir(directory)

def run_ansible_playbook(playbook, inventory, limit=None):
    """Run the Ansible playbook and return the result."""
    run_args = {
        'playbook': playbook,
        'inventory': inventory,
        'limit': limit
    }
    return ansible_runner.run(**run_args)

def process_json_files(directory, items):
    """Process JSON files in a directory and append items to be sent to Zabbix."""
    try:
        json_files = [f for f in os.listdir(directory) if f.endswith('.json')]
    except OSError as e:
        combined_output += f"Error accessing directory {directory}: {e}\n"
        return

    for filename in json_files:
        filepath = os.path.join(directory, filename)
        try:
            data = read_json_output(filepath)
        except json.JSONDecodeError as e:
            combined_output += f"Error reading JSON from {filepath}: {e}\n"
            continue

        hostname = data['hostname']
        if 'agent.hostname' in hostname:
            match = re.search(r'\[s\|(.*)\]', hostname)
            if match:
                hostname = match.group(1)

        items.append(ItemValue(hostname, 'updates.raw', json.dumps([data]).replace("'", '"')))

def send_to_zabbix(sender, items, combined_output):
    """Send data to Zabbix and append the response to combined_output."""
    response = sender.send(items)
    combined_output += f"Response from Zabbix: {response}\n\n"
    return combined_output

def main():
    items = []
    combined_output = ""
    zabbix_sender = Sender(server=ZABBIX_SERVER, port=ZABBIX_PORT)

    parser = argparse.ArgumentParser(description='Run Ansible playbook with optional parameters')
    parser.add_argument('--playbook', default=PLAYBOOK_PATH, help='Path to the playbook template')
    parser.add_argument('--inventory', default=INVENTORY_PATH, help='Path to the inventory file')
    parser.add_argument('--limit', help='Limit the execution to a specific group or host')
    parser.add_argument('--upgrade', default='no', help='Set apt upgrade parameter (yes or no)')
    parser.add_argument('--sshcheck', default='true', help='Check SSH key (true or false) Default: true')
    
    args = parser.parse_args()

    clean_temp_directory('/tmp/updates/')
    os.environ['ANSIBLE_HOST_KEY_CHECKING'] = args.sshcheck

    generate_playbook(args.playbook, '/tmp/sec_compliance_playbook.tmp', args.upgrade)
    
    ansible_result = run_ansible_playbook('/tmp/sec_compliance_playbook.tmp', args.inventory, args.limit)
    os.remove('/tmp/sec_compliance_playbook.tmp')

    process_json_files('/tmp/updates/', items)

    if items:
        combined_output = send_to_zabbix(zabbix_sender, items, combined_output)
    
    with open(ansible_result.stdout.name, 'r') as stdout_file:
        stdout_content = stdout_file.read()
    with open(ansible_result.stderr.name, 'r') as stderr_file:
        stderr_content = stderr_file.read()
    
    clean_stdout = remove_ansi_escape_codes(stdout_content)
    clean_stderr = remove_ansi_escape_codes(stderr_content)
    combined_output += f"STDOUT:\n{clean_stdout}\n\nSTDERR:\n{clean_stderr}"

    response = zabbix_sender.send_value(ZABBIX_DEF_HOSTNAME, 'ansible.result', combined_output)
    print(f"Response from Zabbix for ansible.result: {response}")

if __name__ == "__main__":
    main()
