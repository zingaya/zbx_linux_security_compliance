#!/usr/bin/env python3
# Constants for file paths and Zabbix configuration. Can be overridden via arguments
INVENTORY_PATH = '/etc/ansible/hosts'
ZABBIX_SERVER = "127.0.0.1"
ZABBIX_PORT = "10051"
ZABBIX_HOST = 'MyHost' # Zabbix host where logs from this script will be sent

# Package manager. Add/remove entries as needed
PKG_MGR = ["YUM", "APT"] # Can be overridden via arguments

# Common distros for each package manager. Add/remove entries as needed
YUM_DISTRO = "['RedHat', 'AlmaLinux', 'CentOS', 'Rocky', 'OracleLinux', 'Amazon']"
APT_DISTRO = "['Ubuntu', 'Debian', 'Kali', 'LinuxMint', 'Pop!_OS', 'elementary OS']"

# Temporary directory and template path
TMP_DIR = "/tmp/sec_updates/"
TMP_PLAYBOOK = f"{TMP_DIR}security_playbook.yaml"


##### Do not edit from here #####
import ansible_runner
import argparse
import os
import re
import json
import yaml
import sys
import shutil
from zabbix_utils import ItemValue, Sender

# Clean ANSI escape codes from output
def remove_ansi_escape_codes(text):
    ansi_escape = re.compile(r'\x1b\[[0-9;]*m')
    return ansi_escape.sub('', text)

# Read all JSON result files generated by Ansible
def read_json_output(file_path):
    with open(file_path, 'r') as f:
        return json.load(f)
    
def process_json_files(directory, items, combined_output):
    try:
        files = [f for f in os.listdir(directory) if f.endswith(".json")]
    except OSError as e:
        combined_output += f"Error accessing directory {directory}: {e}\n"
        return

    for filename in files:
        path = os.path.join(directory, filename)
        try:
            data = read_json_output(path)
        except json.JSONDecodeError as e:
            combined_output += f"Error reading JSON from {path}: {e}\n"
            continue

        hostname = data.get("hostname", "unknown")
        if 'agent.hostname' in hostname:
            m = re.search(r'\[s\|(.*)\]', hostname)
            if m:
                hostname = m.group(1)

        items.append(ItemValue(hostname, "updates.raw", json.dumps([data])))

# Send data to Zabbix
def send_to_zabbix(sender, items, combined_output):
    response = sender.send(items)
    combined_output += f"Response from Zabbix: {response}\n\n"
    return combined_output

def build_playbook(args, packages_split):
    # Start playbook
    play = {
        "name": "Linux updates management",
        "hosts": "all",
        "gather_facts": True,
        "become": args.become,
        "vars": {
            "packages_to_handle": packages_split,
            "updates": ""
        },
        "tasks": []
    }

    # Add tasks as needed
    tasks = play["tasks"]
    
    # Always check YUM version lock is installed
    if "YUM" in args.package_manager:
        tasks += [
            {
                "name": "Ensure yum-plugin-versionlock",
                "yum": {"name": "yum-plugin-versionlock", "state": "present"},
                "loop": "{{ packages_to_handle }}",
                "when": [
                    "ansible_facts['distribution'] in " + YUM_DISTRO
                ]
            }
        ]

    # Only if lock/unlock packages found
    if args.unlock_packages:
        if "YUM" in args.package_manager:
            tasks += [
                {
                    "name": "Unlock packages (YUM)",
                    "community.general.yum_versionlock": {"name": "{{ item }}", "state": "absent"},
                    "loop": "{{ packages_to_handle }}",
                    "register": "unlock_result",
                    "when": [
                        "ansible_facts['distribution'] in " + YUM_DISTRO
                    ]
                }
            ]
        if "APT" in args.package_manager:
            tasks += [
                {
                    "name": "Unlock packages (APT)",
                    "command": "apt-mark unhold {{ item }}",
                    "loop": "{{ packages_to_handle }}",
                    "register": "unlock_result",
                    "when": [
                        "ansible_facts['distribution'] in " + APT_DISTRO
                    ]
                }
            ]
    if args.lock_packages:
        if "YUM" in args.package_manager:
            tasks += [
                {
                    "name": "Lock packages (YUM)",
                    "community.general.yum_versionlock": {"name": "{{ item }}", "state": "present"},
                    "loop": "{{ packages_to_handle }}",
                    "register": "lock_result",
                    "when": [
                        "ansible_facts['distribution'] in " + YUM_DISTRO
                    ]
                }
            ]
        if "APT" in args.package_manager:
            tasks += [
                {
                    "name": "Lock packages (APT)",
                    "command": "apt-mark hold {{ item }}",
                    "loop": "{{ packages_to_handle }}",
                    "register": "lock_result",
                    "when": [
                        "ansible_facts['distribution'] in " + APT_DISTRO
                    ]
                }
            ]


    # Always get locked packages
    if "YUM" in args.package_manager:
        tasks += [
            {
                "name": "Get locked (YUM)",
                "shell": "yum versionlock",
                "register": "lock_packages",
                "changed_when": False,
                "when": "ansible_facts['distribution'] in " + YUM_DISTRO
            },
            {
                "name": "Parse YUM locked",
                "set_fact": {
                    "locked": "{{ lock_packages.stdout_lines | select('match', '^(0:([^0-9-]+)|^([^:]+)-0:).*') | map('regex_replace', '^(0:([^0-9-]+)|^([^:]+)-0:).*', '{\"name\": \"\\2\\3\"}') | map('from_json') | list | unique }}"
                },
                "changed_when": False,
                "when": "ansible_facts['distribution'] in " + YUM_DISTRO
            }
        ]
    if "APT" in args.package_manager:
        tasks += [
            {
                "name": "Get locked (APT)",
                "shell": "apt-mark showhold",
                "register": "lock_packages",
                "changed_when": False,
                "when": "ansible_facts['distribution'] in " + APT_DISTRO
            },
            {
                "name": "Parse APT locked",
                "set_fact": {
                    "locked": "{{ lock_packages.stdout_lines | map('regex_replace', '^(.*)$', '{\"name\": \"\\1\"}') | map('from_json') | list }}"
                },
                "changed_when": False,
                "when": "ansible_facts['distribution'] in " + APT_DISTRO
            }
        ]
            
    # Only if argument --upgrade
    if args.upgrade == "yes":
        if "YUM" in args.package_manager:
            tasks += [
                {
                    "name": "Upgrade YUM",
                    "yum": {"name": "*", "state": "latest"},
                    "register": "upgrade_result",
                    "when": [
                        "ansible_facts['distribution'] in " + YUM_DISTRO
                    ]
                }
            ]
        if "APT" in args.package_manager:
            tasks += [
                {
                    "name": "Upgrade APT",
                    "apt": {"update_cache": True, "upgrade": "yes"},
                    "register": "upgrade_result",
                    "changed_when": False,
                    "when": [
                        "ansible_facts['distribution'] in " + APT_DISTRO
                    ]
                }
            ]

    # Always check for updates
    if "YUM" in args.package_manager:
        tasks += [
            {
                "name": "Check YUM updates",
                "yum": {"list": "updates"},
                "register": "yum_updates",
                "changed_when": False,
                "when": "ansible_facts['distribution'] in " + YUM_DISTRO
            },
            {
                "name": "Parse YUM updates",
                "set_fact": {
                    "updates": "{{ yum_updates.results | list }}"
                },
                "when": "ansible_facts['distribution'] in " + YUM_DISTRO
            }
        ]
    if "APT" in args.package_manager:
        tasks += [
            {
                "name": "Check APT updates",
                "shell": "apt list --upgradeable | grep -E '^[a-zA-Z0-9.-]+/' | awk -F/ '{print $1}'",
                "register": "apt_updates",
                "changed_when": False,
                "when": "ansible_facts['distribution'] in " + APT_DISTRO
            },
            {
                "name": "Parse APT updates",
                "set_fact": {
                    "updates": "{{ apt_updates.stdout_lines | map('regex_replace', '^(.*)$', '{ \"name\": \"\\1\" }') | map('from_json') | list }}"
                },
                "when": "ansible_facts['distribution'] in " + APT_DISTRO
            }
        ]

    # Always write final JSON report to disk
    tasks += [
        {
            "name": "Get hostname",
            "shell": "(zabbix_agent2 -t agent.hostname || zabbix_agent -t agent.hostname || zabbix_agentd -t agent.hostname) 2>/dev/null | grep hostname || cat /etc/hostname",
            "register": "cmd_output",
            "changed_when": False
        },
        {
            "name": "Set hostname",
            "set_fact": {"hostname": "{{ cmd_output.stdout }}"}
        },
        {
            "name": "Generate filename",
            "set_fact": {
                "filename": "{{ hostname | regex_replace('.*\\|(.+?)\\]', '\\1') }}.json"
            },
            "delegate_to": "localhost"
        },
        {
            "name": "Write updates to file",
            "lineinfile": {
                "path": TMP_DIR + "/{{ filename }}",
                "line": "{{ {'hostname': hostname, 'current_date': now(utc=true), 'updates': updates, 'locked_packages': locked | default([]), 'distro': ansible_facts['distribution'], 'distro_ver': ansible_facts['distribution_version'], 'kernel': ansible_facts['kernel'], 'ipv4_addresses': ansible_facts['all_ipv4_addresses'], 'ipv6_addresses': ansible_facts['all_ipv6_addresses']} | to_json }}",
                "create": True,
                "mode": "0644"
            },
            "delegate_to": "localhost"
        }
    ]

    # Finally, transform JSON to YAML playbook and write the file
    with open(TMP_PLAYBOOK, "w") as f:
        yaml.dump([play], f, indent=2, sort_keys=False, default_flow_style=False)

def main():
    # Check if another instance of this script is already running
    if os.path.exists(TMP_PLAYBOOK):
        print("Error: Script already running, or " + TMP_PLAYBOOK + " must be deleted manually.")
        print("Exiting")
        sys.exit(0)
    
    # Create arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('--inventory', '-i', default=INVENTORY_PATH)
    parser.add_argument('--zabbix-server', default=ZABBIX_SERVER)
    parser.add_argument('--zabbix-port', default=ZABBIX_PORT)
    parser.add_argument('--zabbix-host', default=ZABBIX_HOST)
    parser.add_argument('--limit', '-l')
    parser.add_argument('--upgrade', '-u', action='store_const', const='yes', default='no')
    parser.add_argument('--ignore-sshcheck', '-k', action='store_true')
    parser.add_argument('--become', '-b', action='store_const', const='yes', default='no')
    parser.add_argument('--debug', action='store_true')
    #parser.add_argument('--dry-run', action='store_true') # Not implemented yet
    parser.add_argument('--package-manager', default=PKG_MGR)
    parser.add_argument('--lock-packages', '-L')
    parser.add_argument('--unlock-packages', '-U')
    args = parser.parse_args()
    
    # Change SSH host key checking. Same as 'ssh -o StrictHostKeyChecking=no'
    os.environ['ANSIBLE_HOST_KEY_CHECKING'] = 'false' if args.ignore_sshcheck else 'true'

    # Read string of packages and transform into a list
    packages_split = args.lock_packages.split() if args.lock_packages else []
    packages_split = args.unlock_packages.split() if args.unlock_packages else []
    
    # Prepare temp dir
    try:
        shutil.rmtree(TMP_DIR)
    except FileNotFoundError:
        pass
    os.mkdir(TMP_DIR)
    
    try:
        # Build playbook YAML    
        build_playbook(args, packages_split)

        # Execute Ansible
        ansible_result = ansible_runner.run(playbook=TMP_PLAYBOOK, inventory=args.inventory, limit=args.limit)
        
        # Prepare Zabbix connection
        sender = Sender(server=args.zabbix_server, port=args.zabbix_port)    

        # Build JSON for each host, as individual items, to be sent to Zabbix
        items = []
        combined_output = ""
        process_json_files(TMP_DIR, items, combined_output)
        # If items exist, send them to Zabbix
        if items:
            combined_output = send_to_zabbix(sender, items, combined_output)
            
        # Collect STDOUT and STDERR to log, to be sent to Zabbix into the host using "ZABBIX_HOST"
        with open(ansible_result.stdout.name) as f:
            clean_stdout = remove_ansi_escape_codes(f.read())
        with open(ansible_result.stderr.name) as f:
            clean_stderr = remove_ansi_escape_codes(f.read())
        combined_output += f"\nSTDOUT:\n{clean_stdout}\n\nSTDERR:\n{clean_stderr}"
        
        # Send log to Zabbix
        response = sender.send_value(args.zabbix_host, "ansible.result", combined_output)
        print(f"Response from Zabbix for ansible.result: {response}")
        
        # Print debug info if enabled
        if args.debug:
            print("ANSIBLE_HOST_KEY_CHECKING: " + os.environ['ANSIBLE_HOST_KEY_CHECKING'])
            print("PKG_MGR: " + str(args.package_manager))
            print("ZABBIX_SERVER: " + args.zabbix_server)
            print("ZABBIX_PORT: " + args.zabbix_port)
            print("ZABBIX_HOST: " + args.zabbix_host)
            print("INVENTORY: " + args.inventory)
            
            print(f"\nYAML:")
            with open(TMP_PLAYBOOK) as playr:
                print(playr.read())
            print("SENT TO ZABBIX:\n" + str(items))
            print(f"\nContribute to https://github.com/zingaya/zbx_linux_security_compliance\n")
            
    except Exception as e:
        print(f"Error: {e}")    
    
    finally:
        # Clean up temporary files
        shutil.rmtree(TMP_DIR)

if __name__ == "__main__":
    main()
