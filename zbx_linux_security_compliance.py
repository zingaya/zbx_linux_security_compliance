#!/usr/bin/env python3
# Constants for file paths and Zabbix configuration. Can be overridden via arguments
INVENTORY_PATH = '/etc/ansible/hosts'
ZABBIX_SERVER = '127.0.0.1'
ZABBIX_PORT = '10051'
ZABBIX_HOST = 'MyHost' # Zabbix host where logs from this script will be sent
USER_LOGIN = 'root'

# Allowed package manager. Add/remove entries as needed
PKG_MGR = ["yum", "apt", "dnf"] # Can be overridden via arguments

# Temporary directory and template path
TMP_DIR = "/tmp/sec_updates"

##### Do not edit from here #####
import ansible_runner
import argparse
import os
import re
import json
import yaml
import sys
import shutil
import time
from pathlib import Path
from zabbix_utils import ItemValue, Sender
from collections import defaultdict

# Read all JSON result files generated by Ansible
def process_json_files(directory, items, combined_output, host_list):
    try:
        directory_path = Path(directory)
        files = [f for f in directory_path.glob("*.json")]
    except OSError as e:
        combined_output += f"Error accessing directory {directory}: {e}\n"
        return

    for filename in files:
        path = os.path.join(directory, filename)
        try:
            with open(path, 'r') as f:
                data = json.load(f)
        except json.JSONDecodeError as e:
            combined_output += f"Error reading JSON from {path}: {e}\n"
            continue

        hostname = data.get("hostname", "unknown")
        if 'agent.hostname' in hostname:
            m = re.search(r'\[s\|(.*)\]', hostname)
            if m:
                hostname = m.group(1)

        # Merge host info from JSON file and the facts from host_list
        host_info = host_list.get(data["inventory_hostname"], {})
        data.update(host_info)  # Use update for merging dictionaries

        items.append(ItemValue(hostname, "updates.raw", json.dumps([data])))

# Send data to Zabbix
def send_to_zabbix(sender, items, combined_output):
    response = sender.send(items)
    combined_output += f"Response from Zabbix: {response}\n\n"
    return combined_output

def build_playbook(args, packages_split_lock, packages_split_unlock, package_mgr):
    # Start playbook
    play = {
        "name": "Linux updates management (" + package_mgr + ")",
        "hosts": "all",
        "gather_facts": False,
        "become": args.become,
        "vars": {
            "packages_to_lock": packages_split_lock,
            "packages_to_unlock": packages_split_unlock,
            "updates": ""
        },
        "tasks": []
    }

    # Add tasks as needed
    tasks = play["tasks"]
 
    # Always check YUM version lock is installed
    if package_mgr in ("yum", "dnf"):
        tasks += [
            {
                "name": "Ensure yum-plugin-versionlock",
                "yum": {"name": "yum-plugin-versionlock", "state": "present"}
            }
        ]

    # Only if lock/unlock packages found
    if args.unlock_packages:
        if package_mgr in ("yum", "dnf"):
            tasks += [
                {
                    "name": "Unlock packages (YUM)",
                    "community.general.yum_versionlock": {"name": "{{ item }}", "state": "absent"},
                    "loop": "{{ packages_to_unlock }}",
                    "register": "unlock_result"
                }
            ]
        if package_mgr in ("apt"):
            tasks += [
                {
                    "name": "Unlock packages (APT)",
                    "command": "apt-mark unhold {{ item }}",
                    "loop": "{{ packages_to_unlock }}",
                    "register": "unlock_result"
                }
            ]
    if args.lock_packages:
        if package_mgr in ("yum", "dnf"):
            tasks += [
                {
                    "name": "Lock packages (YUM)",
                    "community.general.yum_versionlock": {"name": "{{ item }}", "state": "present"},
                    "loop": "{{ packages_to_lock }}",
                    "register": "lock_result"
                }
            ]
        if package_mgr in ("apt"):
            tasks += [
                {
                    "name": "Lock packages (APT)",
                    "command": "apt-mark hold {{ item }}",
                    "loop": "{{ packages_to_lock }}",
                    "register": "lock_result"
                }
            ]


    # Always get locked packages
    if package_mgr in ("yum", "dnf"):
        tasks += [
            {
                "name": "Get locked (YUM)",
                "shell": "yum versionlock",
                "register": "lock_packages",
                "changed_when": False
            },
            {
                "name": "Parse YUM locked",
                "set_fact": {
                    "locked": "{{ lock_packages.stdout_lines | select('match', '^(0:([^0-9-]+)|^([^:]+)-0:).*') | map('regex_replace', '^(0:([^0-9-]+)|^([^:]+)-0:).*', '{\"name\": \"\\2\\3\"}') | map('from_json') | list | unique }}"
                },
                "changed_when": False
            }
        ]
    if package_mgr in ("apt"):
        tasks += [
            {
                "name": "Get locked (APT)",
                "shell": "apt-mark showhold",
                "register": "lock_packages",
                "changed_when": False
            },
            {
                "name": "Parse APT locked",
                "set_fact": {
                    "locked": "{{ lock_packages.stdout_lines | map('regex_replace', '^(.*)$', '{\"name\": \"\\1\"}') | map('from_json') | list }}"
                },
                "changed_when": False
            }
        ]
            
    # Only if argument --upgrade
    if args.upgrade == "yes":
        if package_mgr in ("yum", "dnf"):
            tasks += [
                {
                    "name": "Upgrade YUM",
                    "yum": {"name": "*", "state": "latest"},
                    "register": "upgrade_result"
                }
            ]
        if package_mgr in ("apt"):
            tasks += [
                {
                    "name": "Upgrade APT",
                    "apt": {"update_cache": True, "upgrade": "yes"},
                    "register": "upgrade_result",
                    "changed_when": False
                }
            ]

    # Always check for updates
    if package_mgr in ("yum", "dnf"):
        tasks += [
            {
                "name": "Check YUM updates",
                "yum": {"list": "updates"},
                "register": "yum_updates",
                "changed_when": False
            },
            {
                "name": "Parse YUM updates",
                "set_fact": {
                    "updates": "{{ yum_updates.results | list }}"
                }
            }
        ]
    if package_mgr in ("apt"):
        tasks += [
            {
                "name": "Check APT updates",
                "shell": "apt list --upgradeable | grep -E '^[a-zA-Z0-9.-]+/' | awk -F/ '{print $1}'",
                "register": "apt_updates",
                "changed_when": False
            },
            {
                "name": "Parse APT updates",
                "set_fact": {
                    "updates": "{{ apt_updates.stdout_lines | map('regex_replace', '^(.*)$', '{ \"name\": \"\\1\" }') | map('from_json') | list }}"
                }
            }
        ]

    # Always write final JSON report to disk
    tasks += [
        {
            "name": "Get hostname",
            "shell": "(zabbix_agent2 -t agent.hostname || zabbix_agent -t agent.hostname || zabbix_agentd -t agent.hostname) 2>/dev/null | grep hostname || cat /etc/hostname",
            "register": "cmd_output",
            "changed_when": False
        },
        {
            "name": "Set hostname",
            "set_fact": {"hostname": "{{ cmd_output.stdout }}"}
        },
        {
            "name": "Generate filename",
            "set_fact": {
                "filename": "{{ hostname | regex_replace('.*\\|(.+?)\\]', '\\1') }}.json"
            },
            "delegate_to": "localhost"
        },
        {
            "name": "Write updates to file",
            "lineinfile": {
                "path": TMP_DIR + "/{{ filename }}",
                "line": "{{ {'hostname': hostname, 'inventory_hostname': inventory_hostname, 'current_date': now(utc=true), 'updates': updates, 'locked_packages': locked | default([])} | to_json }}",
                #, 'distro': ansible_facts['distribution'], 'distro_ver': ansible_facts['distribution_version'], 'kernel': ansible_facts['kernel']} 
                "create": True,
                "mode": "0644"
            },
            "delegate_to": "localhost"
        }
    ]

    # Finally, transform JSON to YAML playbook and write the file
    with open(f"{TMP_DIR}/{package_mgr}_playbook.yaml", "w") as f:
        yaml.dump([play], f, indent=2, sort_keys=False, default_flow_style=False)

    printverbose(f"Template created {TMP_DIR}/{package_mgr}_playbook.yaml")

# Print if verbose is true
def printverbose(string):
    if verbose:
        print(string)

def main():
    print("Initializing...")

    # Remove trailing '/' if any
    global TMP_DIR  # Declare it as global to modify it
    TMP_DIR = TMP_DIR.rstrip('/')

    # Check if another instance of this script is already running
    if os.path.exists(f"{TMP_DIR}/.lock"):
        print("Error: Script already running, or " + f"{TMP_DIR}/.lock" + " must be deleted manually.")
        print("Exiting")
        sys.exit(0)
    else:
        # Prepare temp dir and lock
        try:
            shutil.rmtree(TMP_DIR)
        except FileNotFoundError:
            pass
        os.mkdir(TMP_DIR)
        lock = os.open(f"{TMP_DIR}/.lock", os.O_CREAT | os.O_EXCL | os.O_WRONLY)
        os.close(lock)

    # Create arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('--inventory', '-i', default=INVENTORY_PATH)
    parser.add_argument('--zabbix-server', default=ZABBIX_SERVER)
    parser.add_argument('--zabbix-port', default=ZABBIX_PORT)
    parser.add_argument('--zabbix-host', default=ZABBIX_HOST)
    parser.add_argument('--limit', '-l', default='all')
    parser.add_argument('--upgrade', '-u', action='store_const', const='yes', default='no')
    parser.add_argument('--ignore-sshcheck', '-k', action='store_true')
    parser.add_argument('--become', '-b', action='store_const', const='yes', default='no')
    parser.add_argument('--verbose', '-v', action='store_true')
    parser.add_argument('--user', default=USER_LOGIN)
    #parser.add_argument('--dry-run', action='store_true') # Not implemented yet
    #parser.add_argument('--privkey', '-K') # Not implemented yet
    parser.add_argument('--package-manager', default=PKG_MGR)
    parser.add_argument('--lock-packages', '-L')
    parser.add_argument('--unlock-packages', '-U')
    try:
        args = parser.parse_args()
        # verbose flag
        global verbose
        verbose = args.verbose

        # Change SSH host key checking. Same as 'ssh -o StrictHostKeyChecking=no'
        os.environ['ANSIBLE_HOST_KEY_CHECKING'] = 'false' if args.ignore_sshcheck else 'true'

        # Set user login
        os.environ['ANSIBLE_REMOTE_USER'] = args.user

        # verbose info
        printverbose(f"\nContribute to https://github.com/zingaya/zbx_linux_security_compliance\n")
        printverbose("ANSIBLE_HOST_KEY_CHECKING: " + os.environ['ANSIBLE_HOST_KEY_CHECKING'])
        printverbose("ANSIBLE_REMOTE_USER: " + os.environ['ANSIBLE_REMOTE_USER'])            
        printverbose("PKG_MGR: " + str(args.package_manager))
        printverbose("ZABBIX_SERVER: " + args.zabbix_server)
        printverbose("ZABBIX_PORT: " + args.zabbix_port)
        printverbose("ZABBIX_HOST: " + args.zabbix_host)
        printverbose("INVENTORY: " + args.inventory)
        
        # Read string of packages and transform into a list
        packages_split_lock = args.lock_packages.split() if args.lock_packages else []
        packages_split_unlock = args.unlock_packages.split() if args.unlock_packages else []

        # Gather package manager info
        print("Gatthering hosts data...")
        r1 = ansible_runner.run(module='setup', module_args='gather_subset=system', inventory=args.inventory, host_pattern=args.limit, streamer='file', quiet=not args.verbose)
        
        # To do
        #[WARNING]: Could not match supplied host pattern, ignoring: 10.0.0.1
        #[WARNING]: No hosts matched, nothing to do

        host_list = {}

        for event in r1.events:
            result = re.match(r'^runner_on_', event.get("event"))
            if result:
                host = event['event_data']['host']
                if event.get("event") == "runner_on_ok":        
                    facts = event['event_data']['res'].get('ansible_facts', {})
                    host_list[host] = {
                        'pkg_mgr': facts.get('ansible_pkg_mgr'),
                        'distribution': facts.get('ansible_distribution'),
                        'distribution_version': facts.get('ansible_distribution_version'),
                        'kernel': facts.get('ansible_kernel'),
                        'selinux': facts.get('ansible_selinux')
                    }
                else:
                    host_list[host] = {'error': event.get("event")}

        pkg_mgr_list = defaultdict(list)

        for host, data in host_list.items():
            pkg_mgr = data.get("pkg_mgr")
            if pkg_mgr:
                pkg_mgr_list[pkg_mgr].append(host)

        printverbose("Inventory details: " + str(host_list))
        printverbose("Package manager grouping: " + str(dict(pkg_mgr_list)))

        # Execute Ansible playbooks for each package manager
        runners = []

        print("Running Ansible playbook(s)...")
        for pkgmgr in pkg_mgr_list:
            # Check if pkg_mgr is in "allowed"
            if pkgmgr in args.package_manager:
                # Build playbook YAML per pkg_mgr
                build_playbook(args, packages_split_lock, packages_split_unlock, pkgmgr)

                limit_host = ','.join(pkg_mgr_list[pkgmgr])

                # Execute Ansible (fork)
                ident, r2 = ansible_runner.run_async(private_data_dir=TMP_DIR, playbook=f"{TMP_DIR}/{pkgmgr}_playbook.yaml", inventory=args.inventory, limit=limit_host, streamer='file', quiet=not args.verbose)
                printverbose(f"Started playbook for {pkgmgr} on: {limit_host}")
                runners.append((pkgmgr, r2))

        # Wait for all to finish by polling their status
        while runners:
            for pkgmgr, r2 in list(runners):  # Copy the list to prevent modification during iteration
                if r2.status == 'successful' or r2.status == 'failed' or r2.status == 'canceled':
                    printverbose(f"{pkgmgr} finished with status: {r2.status}, rc={r2.rc}")
                    runners.remove((pkgmgr, r2))
            time.sleep(1)  # Poll every second

        print("Ansible playbook(s) finished")

        # Prepare Zabbix connection
        sender = Sender(server=args.zabbix_server, port=args.zabbix_port)    

        # Build JSON for each host, as individual items, to be sent to Zabbix
        items = []
        combined_output = ""
        process_json_files(TMP_DIR, items, combined_output, host_list)
        # If items exist, send them to Zabbix
        if items:            
            combined_output = send_to_zabbix(sender, items, combined_output)

            printverbose("Sent to Zabbix: " + str(items))
            printverbose(combined_output)

        # To do
        # combined_output = "Good hosts:\n"
          

        # Gatther failed hosts, stdout & stderr for each Ansible run
        combined_output = "Failed hosts:\n"

        for host, err_detail in host_list.items():
            if 'error' in err_detail:
                combined_output += f"{host}: {err_detail['error']}\n"

        combined_output += "Ansible log:"
        output_files = Path(TMP_DIR + "/artifacts")
        for output_file in output_files.rglob('stdout'):
            with open(output_file) as f:
                filtered_lines = [line for line in f if line.startswith("PLAY [") or line.startswith("TASK [") or line.startswith("failed:")]
                for line in filtered_lines:
                    combined_output += line

        printverbose(combined_output)
        
        # Send log to Zabbix
        response = sender.send_value(args.zabbix_host, "ansible.result", combined_output)

        if json.loads(str(response)).get('failed') == 1:
            print("I could not send logs to Zabbix. Check hostname variable and if the host exists on Zabbix with the template.")
        
        printverbose(f"Response from Zabbix (log host): {response}")
         
    except Exception as e:
        msg = str(e)
        if "Couldn't connect to all of cluster nodes" in msg:
            # For better understanding to "what" is not connecting
            msg = msg.replace("all of cluster nodes", "Zabbix API")
        print(f"Error: {msg}")
    
    finally:
        # Clean up temporary files
        shutil.rmtree(TMP_DIR)

if __name__ == "__main__":
    main()
